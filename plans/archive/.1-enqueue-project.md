### Queuing Phases (as listed)
For each phase, sequentially use 'v0 feature phase-{num} "description" --after {previous-phase} to queue work for that phase.  Include instructions to reference the (a) docs files (including appropriate links the description) (b) previously written related specs that should exist (include a list of expected specs from the immedaite prior phase) (c) the details from the outline.  

### Queuing Checkpoints (8 queued 'v0 feature's - A, B, C, D, E, F, G, H)
Also log in-sequence features with 'v0 feature' blocking following phases on the checkpoint/milestone feature for each _checkpoint_.  For the checkpoints, sequentially first, (a) add a pre-checkpoint fix 'feature' to fix formatting, lint failures and failing specs and tests (b) add a checkpoint feature to perform the dogfooding and/or checkpoint instructions and document it in reports/ with a specific checkpoint report name, including ways that behavior did not work as expect (c) add a follow-up 'v0 feature' to re-factor as needed or perform fixes to close expected behavioral gaps  (d) benchmark, identifying bottlenecks if ready (e) address bottlenecks with small to medium performance fixes (f) identify quick wins for cleaning up, removing backwards compatibility, finishing partial migrations, deadcode cleanup, etc (g) fix any bugs from the prior refactors (behavioral gaps, perfomance, and tech debt) and (h) address techdebt to dry up common patterns in tests, shorten tests using yare where possible.

Except the first, ensure all phases and checkpoint tasks are queued using '--after'.

Order phases and checkpoint 'feature's strictly.

Always use 'v0 feature' and not any other commands.